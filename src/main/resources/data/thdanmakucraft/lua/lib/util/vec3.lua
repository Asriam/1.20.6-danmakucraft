---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2025/1/23 下午 08:33
---

---@class abstractVec3
---@field x number
---@field y number
---@field z number
local abstractVec3 = {}

---@field x number
---@field y number
---@field z number
---@class util.Vec3:abstractVec3
local vec3 = {}
local metatable = {__index = vec3 }
core.registerMetaTable("util.vec3",metatable)
core.setupVec3Lib(vec3,metatable)
---@param vec3 table
---@return util.Vec3
function vec3.of(_vec3)
    local v = {
        x = _vec3.x or 0,
        y = _vec3.y or 0,
        z = _vec3.z or 0
    }
    setmetatable(v, metatable)
    return v
end

---@param x number
---@param y number
---@param z number
---@return util.Vec3
function vec3.new(x, y, z)
    local v = {
        x = x or 0,
        y = y or 0,
        z = z or 0
    }
    setmetatable(v, metatable)
    return v
end

util.vec3 = vec3

vec3.zero = vec3.new(0, 0, 0)
vec3.one = vec3.new(1, 1, 1)

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:vectorTo(_vec3)
    return vec3.new(_vec3.x - self.x, _vec3.y - self.y, _vec3.z - self.z)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:normalize()
    local length = self:length()
    return vec3.new(self.x / length, self.y / length, self.z / length)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:dot(_vec3)
    return vec3.new(self.x * _vec3.x, self.y * _vec3.y, self.z * _vec3.z)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:cross(_vec3)
    return vec3.new(self.y * _vec3.z - self.z * _vec3.y, self.z * _vec3.x - self.x * _vec3.z, self.x * _vec3.y - self.y * _vec3.x)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:subtract(_vec3)
    return vec3.new(self.x - _vec3.x, self.y - _vec3.y, self.z - _vec3.z)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:add(_vec3)
    return vec3.new(self.x + _vec3.x, self.y + _vec3.y, self.z + _vec3.z)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:distanceTo(_vec3)
    return math.sqrt((self.x - _vec3.x) ^ 2 + (self.y - _vec3.y) ^ 2 + (self.z - _vec3.z) ^ 2)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:distanceToSqr(_vec3)
    return (self.x - _vec3.x) ^ 2 + (self.y - _vec3.y) ^ 2 + (self.z - _vec3.z) ^ 2
end

---@param _number number
---@return util.Vec3
function vec3:scale(_number)
    return vec3.new(self.x * _number, self.y * _number, self.z * _number)
end

---@return util.Vec3
function vec3:reverse()
    return vec3.new(-self.x, -self.y, -self.z)
end

---@param _vec3 util.Vec3
---@return util.Vec3
function vec3:multiply(_vec3)
    return vec3.new(self.x * _vec3.x, self.y * _vec3.y, self.z * _vec3.z)
end

---@param _vec3 util.Vec3
---@return boolean
function vec3:equals(_vec3)
    return self.x == _vec3.x and self.y == _vec3.y and self.z == _vec3.z
end

---@param _number number
---@return util.Vec3
function vec3:xRot(_number)
    local cos = math.cos(_number)
    local sin = math.sin(_number)
    return vec3.new(self.x, self.y * cos - self.z * sin, self.y * sin + self.z * cos)
end

---@param _number number
---@return util.Vec3
function vec3:yRot(_number)
    local cos = math.cos(_number)
    local sin = math.sin(_number)
    return vec3.new(self.x * cos - self.z * sin, self.y, self.x * sin + self.z * cos)
end

---@param _number number
---@return util.Vec3
function vec3:zRot(_number)
    local cos = math.cos(_number)
    local sin = math.sin(_number)
    return vec3.new(self.x * cos + self.y * sin, self.y * cos - self.x * sin, self.z)
end

---@return util.Vec3
function vec3:length()
    return math.sqrt(self.x ^ 2 + self.y ^ 2 + self.z ^ 2)
end

---@return util.Vec3
function vec3:lengthSquared()
    return self.x ^ 2 + self.y ^ 2 + self.z ^ 2
end
